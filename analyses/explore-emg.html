<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.551">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Lasse Hjorth Madsen">
<meta name="dcterms.date" content="2024-03-25">

<title>Explore EMG Normalization</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../analyses/explore-emg.html">THEORY</a></li><li class="breadcrumb-item"><a href="../analyses/explore-emg.html">Explore EMG Normalization</a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">HOME</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">THEORY</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../analyses/explore-emg.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Explore EMG Normalization</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../analyses/met-precision.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Match Equity Precision</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../analyses/janowski.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Janowski Formulars</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../analyses/many-takepoints.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exploring take points</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../analyses/bgmoves-analysis.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mistake, errors and statistics</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">PRAXIS</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../analyses/milestones-2023.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Milestones III, 2023</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../analyses/mistakes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Mistakes were made</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../analyses/opening-mistakes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Opening checker play errors</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../analyses/middle-game-cubes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Middle game cube benchmark</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../analyses/hit-or-point.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Hit or point decisions</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#why-this" id="toc-why-this" class="nav-link active" data-scroll-target="#why-this">Why this?</a></li>
  <li><a href="#introduction" id="toc-introduction" class="nav-link" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#emg-normalization" id="toc-emg-normalization" class="nav-link" data-scroll-target="#emg-normalization">EMG normalization</a></li>
  <li><a href="#the-problem" id="toc-the-problem" class="nav-link" data-scroll-target="#the-problem">The problem</a></li>
  <li><a href="#more-scores" id="toc-more-scores" class="nav-link" data-scroll-target="#more-scores">More scores</a></li>
  <li><a href="#checker-play-errors" id="toc-checker-play-errors" class="nav-link" data-scroll-target="#checker-play-errors">Checker play errors</a></li>
  <li><a href="#conclusions" id="toc-conclusions" class="nav-link" data-scroll-target="#conclusions">Conclusions</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../analyses/explore-emg.html">THEORY</a></li><li class="breadcrumb-item"><a href="../analyses/explore-emg.html">Explore EMG Normalization</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Explore EMG Normalization</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Lasse Hjorth Madsen </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">March 25, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="why-this" class="level2">
<h2 class="anchored" data-anchor-id="why-this">Why this?</h2>
<p>This note explores how eXtreme Gammon normalizes mwc, <em>Match Winning Chances</em>, to emg, <em>Equivalent to Money Game</em>, a metric that is (supposedly) comparable to money game equities. It is similar to what Jeremy Bagai did years ago in a detailed analysis <a href="http://www.fortuitouspress.com/emg">here</a>.</p>
</section>
<section id="introduction" class="level2">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>In backgammon money games mistakes are usually evaluated in terms of equities, <span class="math inline">\(E\)</span>, or <em>expected value</em>. <span class="math inline">\(E=0\)</span> means that the game is even. Equities are typically <em>normalized</em> so the level of the cube and the stakes are <em>not</em> reflected in the size of mistakes: <span class="math inline">\(E=0.1\)</span> means that the expected value of a position is one tenth of the cube value. If you made a <span class="math inline">\(0.05\)</span> error, your position’s expected value just dropped by five percent of the cube value.</p>
<p>In match play, the natural unit of measurement is match winning chances, mwc. For example, trailing 3-away, 2-away, sometimes written as (-3,-2), yields <span class="math inline">\(mwc=0.40\)</span>, assuming strong, equal players. Unless otherwise noted, all mentioned equities are from the Kazaross XG2 match equity table, used as default by eXtreme Gammon (XG).</p>
<p>The <span class="math inline">\(mwc\)</span> at stake varies by score. At double match point, a one point gain is worth <span class="math inline">\(0.5\ mwc\)</span>, the difference between an even game, <span class="math inline">\(mwc=0.50\)</span> and a sure victory, <span class="math inline">\(mwc=1.00\)</span>. At the beginning of a 17-point match one point is worth only about <span class="math inline">\(0.04\ mwc\)</span>.</p>
<p>In a sense, double match point is like playing for $10 per point, compared to $0.8 per point at the beginning of the match.</p>
<p>Also, the value of one point is different for the leader and the trailer; at (-3,-2) one point is worth <span class="math inline">\(0.10\ mwc\)</span> for the trailer but <span class="math inline">\(0.15\ mwc\)</span> for the leader.</p>
</section>
<section id="emg-normalization" class="level2">
<h2 class="anchored" data-anchor-id="emg-normalization">EMG normalization</h2>
<p>As mentioned, in money game we often like to compare errors without considering the level of the cube and the stakes. We rarely say things like “Taking that three-roll position cost me about $4.5 because the cube was at 4 and we played for $10 per point.” It is more common to say that the take is a 0.15 error.</p>
<p>This way, we can compare <em>conceptual</em> errors by abstracting away the specifics. If you would like the actual cost of taking, you would multiply the 0.15 error by the cube value and the stakes.</p>
<p>Likewise, it can be useful to normalize match play errors, so that we can compare them to money game, and so we can compare errors across scores. If some error loses <span class="math inline">\(0.03\ mwc\)</span> at (-4, -5), but only <span class="math inline">\(0.01\ mwc\)</span> at (-17, -10) is that because the first score is closer to the end of the match, where points are more valuable, or is it because the first error is a bigger one, conceptually? And how big would the same mistake have been in a money game?</p>
<p>This is where emg (Equivalent to Money Game) comes in. The idea is to scale the difference between losing a single point and winning a single point in a match to the interval <span class="math inline">\([-1;+1]\)</span>, that we use in money game.</p>
<p>For example, at (-3,-7) the leader has <span class="math inline">\(mwc\)</span> of about <span class="math inline">\(0.76\)</span>. If he loses one point and gets to (-3,-6) that drops to <span class="math inline">\(0.71\)</span>. If he wins one point for (-2,-7) that rises to <span class="math inline">\(0.84\)</span>. The range is <span class="math inline">\([0.71;0.84]\)</span>, and the difference between winning and losing a single point is <span class="math inline">\(0.84-0.71 = 0.13\)</span>. We can scale any <span class="math inline">\(mwc\)</span> value to the corresponding money interval <span class="math inline">\([-1;+1]\)</span> like this:</p>
<p><span class="math display">\[emg =\frac{mwc-0.71}{0.13}\times{2}-1\]</span></p>
<p>So the <span class="math inline">\(emg\)</span> for our minimal value of <span class="math inline">\(mwc=0.71\)</span> becomes:</p>
<p><span class="math display">\[emg =\frac{0.71-0.71}{0.13}\times{2}-1=-1\]</span></p>
<p>And for our maximum value of <span class="math inline">\(mwc=0.84\)</span> we get:</p>
<p><span class="math display">\[emg =\frac{0.84-0.71}{0.13}\times{2}-1=+1\]</span> Of course, with the doubling cube and gammons, you can be even worse off and end up outside the interval, like if you’re sure to lose a gammon and <span class="math inline">\(E=-2.00\)</span>.</p>
<p>More generally, if <span class="math inline">\(mwc_{min}\)</span> is the match winning chance a player has after losing the cube value, and <span class="math inline">\(mwc_{max}\)</span> is the corresponding chance after winning the cube value, then we can calculate <span class="math inline">\(emg\)</span> from any <span class="math inline">\(mwc\)</span> at any score like this:</p>
<p><span class="math display">\[emg =\frac{mwc-mwc_{min}}{mwc_{max}-mwc_{min}}\times{2}-1\]</span></p>
<p>So if we lead (-3,-7) and mess up the opening roll so our <span class="math inline">\(mwc\)</span> drops from <span class="math inline">\(0.76\)</span> to <span class="math inline">\(0.75\)</span>, then the size of the error in <span class="math inline">\(emg\)</span> would be:</p>
<p><span class="math display">\[emg =\frac{0.75-0.71}{0.13}\times{2}-1=-0.38\]</span></p>
<p>This also means that the leader’s <span class="math inline">\(emg\)</span> at the beginning of the game is negative:</p>
<p><span class="math display">\[emg =\frac{0.76-0.71}{0.13}\times{2}-1=-0.23\]</span></p>
<p>That seems a little funny. The reason is, that in some sense the leader is closer to losing the game that to winning, since the gain by winning is much bigger than the loss from losing. The leader is not in the middle, but closer to the lower end of the interval <span class="math inline">\([-1;1]\)</span>.</p>
<p>This is just one counter-intuitive thing about emg normalization; there are more:</p>
</section>
<section id="the-problem" class="level2">
<h2 class="anchored" data-anchor-id="the-problem">The problem</h2>
<p>Sometimes, the <span class="math inline">\(emg\)</span> appears really broken. Take a pure three-roll position where the non-roller has winning probability, <span class="math inline">\(P(w)\)</span> of:</p>
<p><span class="math display">\[
P(w) = \frac{5}{6}\times\frac{1}{6}\times\frac{5}{6}\ + \ \frac{5}{6}\times\frac{5}{6}\times\frac{5}{6}\times\frac{1}{6} = 0.212
\]</span> Consider two cases of such a position:</p>
<ol type="a">
<li>You’re being doubled trailing (-3,-2)</li>
<li>You’re being redoubled when tied (-3,-3)</li>
</ol>
<p>In both cases you can take for the match (possibly via an automatic redouble), and get <span class="math inline">\(mwc = 0.212\)</span>. Or you can pass and get to (-3,-1) which is <span class="math inline">\(mwc=0.249\)</span> The two cases appear identical. You’re better of passing. Taking would cost <span class="math inline">\(0.249-0.212 = 0.037\ mwc\)</span> in both situations.</p>
<p>But plucking the two cases into our <span class="math inline">\(emg\)</span> formula we get:</p>
<ol type="a">
<li><p><span class="math inline">\(emg =\frac{0.21219-0.24924}{0.5-0.24924}\times{2}-1=-1.296\)</span></p></li>
<li><p><span class="math inline">\(emg =\frac{0.21219-0.24924}{0.75076-0.24924}\times{2}-1=-1.148\)</span></p></li>
</ol>
<p>So at (-3,-2) the mistake of taking comes to a <span class="math inline">\(-0.296\  emg\)</span> error; at (-3,-3) what appears to be an identical mistake comes to a <span class="math inline">\(-0.148\  emg\)</span> error.</p>
<p>You can set up a pure three-roll position in XG and confirm that these are indeed the reported emg errors when accepting a (re-)double at those two scores.</p>
<p>What’s going on?</p>
<p>Inspecting the emg formula, it isn’t that hard to figure out: The <span class="math inline">\(0.037\ mwc\)</span> error just looks smaller when you put it in the wide interval between losing and winning you get at (-3,-3) with cube at 2, compared to the more narrow interval at (-3,-2), cube at 1. As noted, the mwc interval in the two cases are <span class="math inline">\([0.25;0.50]\)</span> and <span class="math inline">\([0.25;0.75]\)</span> respectively.</p>
<p>It is counter intuitive, however, and you wonder if emg fails after all to be useful for comparing errors across scores, and between match play and money games.</p>
<p>On the other hand: Perhaps this is exactly what we want emg to do: A <span class="math inline">\(0.037\ mwc\)</span> error is easier to make at the end of the match, and therefore perhaps shouldn’t count as heavily. Just like a $1 mistake is small when playing for $100 per point, but big when playing for $2 per point.</p>
<p>We can note, like Bagai did in his <a href="http://www.fortuitouspress.com/emg">paper</a>, that a similar observation can be made when you are being doubled to 8 (in the same three-roll position) at (-3,-5). You can again choose between trailing (-3,-1) with <span class="math inline">\(0.249\ mwc\)</span> or playing for the match with <span class="math inline">\(0.212\ mwc\)</span>, which would be a <span class="math inline">\(0.037\ mwc\)</span> error. This time the interval is even wider, so the emg normalized error by taking comes to <span class="math inline">\(-0.099\)</span>. This can be checked with XG.</p>
<p>We can also do a plot similar to the one Bagai showed, to visualize why the normalizations must necessarily result in different emg-values.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="explore-emg_files/figure-html/baggai_plot-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The plot shows three lines, one for each of the three cases. They all pass through the point where <span class="math inline">\(mwc = 0.25\)</span> and <span class="math inline">\(emg = -1.0\)</span> since losing the cube value in all cases results in (-3,-1) with <span class="math inline">\(mwc = 0.25\)</span>. <em>Winning</em> the cube value would result in mwc-values of <span class="math inline">\(0.5; 0.75; 1.00\)</span> respectively.</p>
<p>The emg-values obtained by erroneously taking the cube (left-most data points) are all below <span class="math inline">\(-1.0\ emg\)</span> since in all three cases we have a pass. But they cannot be equal, like we might intuitively expect, since the transformation is linear, and the three lines have different slopes.</p>
</section>
<section id="more-scores" class="level2">
<h2 class="anchored" data-anchor-id="more-scores">More scores</h2>
<p>Let’s look at the size of the error by taking the same three-roll position for more scores, to get a feel for how the emg normalization in general compares to raw mwc.</p>
<p>The money benchmark is the error of accepting a three-roll position, which is easy to calculate, since for money there can’t be any proper recubes. The three-roll position has an expected money game value of <span class="math inline">\(E = 2P(w) - 1 = -0.576\)</span> for the non-roller. So after accepting an initial double, the non-roller faces an average loss of <span class="math inline">\(2\times -0.576=-1.151\)</span> and the position is a money pass, since the loss of one point is just <span class="math inline">\(-1\)</span>. The size of the take error is <span class="math inline">\(-0.151\)</span> (times the cube, times the stake, if you want the loss in real money).</p>
<p>The chart below shows the size of the error of accepting an initial double in a pure three-roll position, at all pre-crawford scores in a 9-point match. Errors are nomalized to emg, as explained above.</p>
<p>(Note that on the x-axis, negative values are the real errors; a positive value is the margin by which the take is correct.)</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="explore-emg_files/figure-html/emg_plot-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>As the chart shows, at six scores the three-roll position is actually a take. The biggest take is, not surprisingly, at (-4,-2) where the non-roller has an automatic redouble that activates exactly the four points needed to win. Also, in some cases, when the non-roller needs two or three points, the high value of those points is enough to turn the position into a take.</p>
<p>The biggest passes are at (-4,-3) and (-2,-2), ignoring that in the later case one player would usually already have doubled by now. In general, the biggest passes are when the roller needs two, three or four points to win. In these cases, a two-point win is particularly valuable.</p>
<p>In about half of all scores the error from taking is <em>bigger</em> than for money, in the other half <em>smaller</em>, when we use the emg normalization to compare.</p>
<p>But we really wanted to figure out if the emg normalization was a good or a bad idea to begin with. So let’s show a similar plot with emg and mwc errors side-by-side:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="explore-emg_files/figure-html/emg_mwc_plot-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The two plots show similar over-all patterns, but also some differences. Of course, both metrics agree on what scores produce takes; when one is negative the other is also, by definition.</p>
<p>The mwc-metric has the biggest error at (-2,-2); emg says this honor goes to (-4,-3). In a way, what emg says is this: ‘Yeah alright, taking at (-2,-2) is a big mistake. But part of the reason is, that there is so much mwc at stake at that score already. Any mistake is bound to be big. So we should adjust for that.’</p>
<p>But should we? It is hard to say. You could argue that <em>conceptually</em> the take is a bigger mistake at (-2,-2) because the score is special. Same thing could be said of (-2,-3) and (-3,-2) where emg also gives a different ranking.</p>
<p>Let’s do a few more plots to see if we can nail this better.</p>
<p>This one shows the same data, but plotted differently, with mwc at the x-axis, and emg at the y-axis.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="explore-emg_files/figure-html/unnamed-chunk-1-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Since the plot shows the same data some of the same things also stand out: (-2,-2) is a bit of an outlier; at (-4,-2) the non-roller has a big take. In general, there’s a reasonable correlation between mwc and emg. It’s worth pointing out that we don’t want a <em>perfect</em> correlation: If all points where placed exactly at the light green trend line, then mwc and emg would be equivalent, same thing on different scales, like Fahrenheit and Celsius. The idea is that emg should be different from mwc, more meaningful, more interpretable.</p>
<p>Let’s do the same plot but with more scores: All combinations from a full 25-point match. (We leave out the (-2,-2) oddball, to give more plotting space to the more ‘normal’ cases.)</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="explore-emg_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Now, the correlation breaks down. In particular, for the very lopsided scores like (-25,-2) and (-18,2), the mwc at stake becomes tiny, so the margin by which the take is correct, is also small. At all the lopsided scores the non-roller appears to have a small take as measured by mwc.</p>
<p>The emg error, on the other hand, is a bit different at (-25,-2) compared to (-18,-2) for example. Just as emg tries to adjust for scores with a <em>lot</em> of mwc at stakes, it also adjust for very <em>little</em> mwc at stake, thus magnifying small mwc’s.</p>
<p>Again, it is debatable if this is really desired behavior or not.</p>
</section>
<section id="checker-play-errors" class="level2">
<h2 class="anchored" data-anchor-id="checker-play-errors">Checker play errors</h2>
<p>One final experiment before we wrap this up. As we have seen, part of the reason that the emg transformation can give surprising results, is that take errors are extrapolated outside the <span class="math inline">\([mwc_{min};mwc_{max}]\)</span> interval that we use for normalization. A take error results in mwc <em>smaller</em> than a ordinary loss of the cube value, <span class="math inline">\(mwc_{min}\)</span>.</p>
<p>Checker play errors, on the other hand, are <em>differences</em> between mwc’s, and the are usually not that big (except in extreme cases).</p>
<p>Let’s consider a toy example: A last-roll bearoff where one player has two checkers left, one on the six point, one on the three point, with a two to play. The opponent owns the cube and has four checkers on her one point. The player has two options for his two:</p>
<ol type="a">
<li>6/4, for <span class="math inline">\(p(w) = \frac{5}{6} \times \frac{17}{36} = 0.394\)</span>, and <span class="math inline">\(E = 2P(w) - 1 = -0.212\)</span></li>
<li>3/1, for <span class="math inline">\(p(w) = \frac{5}{6} \times \frac{15}{36} = 0.347\)</span>, and <span class="math inline">\(E = 2P(w) - 1 = -0.306\)</span></li>
</ol>
<p>For money, 3/1 would be a <span class="math inline">\(-0.306 + 0.212 = -0.094\)</span> error.</p>
<p>At double match point, 3/1 would be a <span class="math inline">\(0.347 - 0.394 = -0.047\ mwc\)</span> error.</p>
<p>Since 6/4 of course would be correct at all scores, and it is fair to say that 3/1 is the same conceptual error at all scores, we would like the emg transformation to produce the same value, no matter the score. One way to think of this: Suppose you’re browsing your matches for bear-off checker play errors, in order to fine tune your skill in that department. Then you would like to flag errors both early and late in the match. But the mwc-error from playing 3/1 at (-1,-1) is <em>16 times</em> bigger than at (-25,-25).</p>
<p>It’s reasonable to think that playing 3/1 shouldn’t be disregarded as an error, just because it happened at (-25,-25) rather that at (-1,-1).</p>
<p>To achieve this, we really need <em>some</em> kind of normalization; looking at mwc will tend to miss errors early in a long match.</p>
<p>Does emg work for this purpose? I think it should, based on the plots and formulas above, but just in case I’m missing something, let’s try to calculate the size of the error of playing 3/1 at all scores, in emg and in mwc:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="explore-emg_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>As expected, emg normalizes the error of playing 3/1 to <span class="math inline">\(-0.0926\)</span> for all scores. (This value is a little off from the earlier mentioned <span class="math inline">\(-0.094\)</span> because of rounding error in that manual calculation.) We see how the mwc error is high near the end of the match, lower at the beginning. (-25,-25) is not the very rightmost data point, because for these scores the mwc-errors are tiny, and the exact value depends on rounding and precision of the match equity table.</p>
</section>
<section id="conclusions" class="level1">
<h1>Conclusions</h1>
<ul>
<li><p>The choice of emg or mwc as a metric, really depends on the purpose. For example:</p>
<ul>
<li><p>If you want to identify, say, the five errors in a match that hurt your winning chances the most, use mwc. This is the ‘true’, absolute cost of errors, in the same way that a specific amount of money would be the ‘true’ cost of errors in money games. These five errors will more likely be found late than early in the match, since this is were the stakes are highest.</p></li>
<li><p>If you want to identify the five errors in a match that could reflect mis-evaluating the position, use emg. As the last-roll example shows, this allows you to compare similar conceptual errors across scores.</p></li>
</ul></li>
<li><p>Be careful of using emg for comparing cube errors across different scores, the results can be surprising, although it is a bit unclear if they should be considered outright misleading.</p></li>
<li><p>Can we do a better normalization than the current emg? The thought that comes to mind, is to use a bigger interval of mwc, like the loss or win of <em>two</em> time the cube and still scale that to <span class="math inline">\([-1;+1]\)</span>. But that requires a bit more thought. Anyway, practically speaking, we’re likely pretty much stuck with the way XG implements emg.</p></li>
</ul>
<p>If you’ve read this far: Thank you. That is really impressive.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/lassehjorthmadsen\.github\.io\/bganalyses\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>